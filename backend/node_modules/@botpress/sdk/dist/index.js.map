{
  "version": 3,
  "sources": ["../src/index.ts", "../src/message.ts", "../src/zui.ts", "../src/interfaces/index.ts", "../src/utils.ts", "../src/integration/definition/branded-schema.ts", "../src/integration/definition/integration-definition.ts", "../src/integration/definition/interface-declaration.ts", "../src/interfaces/llm.ts", "../src/interfaces/text-to-image.ts", "../src/interfaces/schemas/speech-to-text.ts", "../src/interfaces/speech-to-text.ts", "../src/interfaces/schemas/index.ts", "../src/interfaces/sync.ts", "../src/const.ts", "../src/serve.ts", "../src/log.ts", "../src/integration/context.ts", "../src/integration/server.ts", "../src/integration/client/index.ts", "../src/integration/logger.ts", "../src/integration/implementation.ts", "../src/bot/server.ts", "../src/bot/client/index.ts", "../src/bot/context.ts", "../src/bot/implementation.ts"],
  "sourcesContent": ["export * as messages from './message'\nexport * as interfaces from './interfaces'\nexport * from './const'\nexport * from './serve'\nexport * from './zui'\n\nexport { isApiError, RuntimeError } from '@botpress/client'\n\nexport {\n  IntegrationDefinition,\n  IntegrationDefinitionProps,\n  IntegrationImplementation as Integration,\n  IntegrationImplementationProps as IntegrationProps,\n  IntegrationContext,\n  IntegrationLogger,\n  IntegrationSpecificClient,\n  InterfaceDeclaration,\n  InterfaceDeclarationProps,\n  TagDefinition,\n  ConfigurationDefinition,\n  EventDefinition,\n  ChannelDefinition,\n  MessageDefinition,\n  ActionDefinition,\n  StateDefinition,\n  UserDefinition,\n  SecretDefinition,\n  EntityDefinition,\n} from './integration'\n\nexport { Bot, BotProps, BotContext, BotSpecificClient, IntegrationInstance } from './bot'\n", "import { z } from './zui'\n\nconst NonEmptyString = z.string().min(1)\n\nconst textMessageSchema = z.object({\n  text: NonEmptyString,\n})\n\nconst markdownMessageSchema = z.object({\n  markdown: NonEmptyString,\n})\n\nconst imageMessageSchema = z.object({\n  imageUrl: NonEmptyString,\n})\n\nconst audioMessageSchema = z.object({\n  audioUrl: NonEmptyString,\n})\n\nconst videoMessageSchema = z.object({\n  videoUrl: NonEmptyString,\n})\n\nconst fileMessageSchema = z.object({\n  fileUrl: NonEmptyString,\n  title: NonEmptyString.optional(),\n})\n\nconst locationMessageSchema = z.object({\n  latitude: z.number(),\n  longitude: z.number(),\n  address: z.string().optional(),\n  title: z.string().optional(),\n})\n\nconst cardSchema = z.object({\n  title: NonEmptyString,\n  subtitle: NonEmptyString.optional(),\n  imageUrl: NonEmptyString.optional(),\n  actions: z.array(\n    z.object({\n      action: z.enum(['postback', 'url', 'say']),\n      label: NonEmptyString,\n      value: NonEmptyString,\n    })\n  ),\n})\n\nconst choiceSchema = z.object({\n  text: NonEmptyString,\n  options: z.array(\n    z.object({\n      label: NonEmptyString,\n      value: NonEmptyString,\n    })\n  ),\n})\n\nconst carouselSchema = z.object({\n  items: z.array(cardSchema),\n})\n\nconst blocSchema = z.discriminatedUnion('type', [\n  z.object({ type: z.literal('text'), payload: textMessageSchema }),\n  z.object({ type: z.literal('markdown'), payload: markdownMessageSchema }),\n  z.object({ type: z.literal('image'), payload: imageMessageSchema }),\n  z.object({ type: z.literal('audio'), payload: audioMessageSchema }),\n  z.object({ type: z.literal('video'), payload: videoMessageSchema }),\n  z.object({ type: z.literal('file'), payload: fileMessageSchema }),\n  z.object({ type: z.literal('location'), payload: locationMessageSchema }),\n])\n\nconst blocsSchema = z.object({\n  items: z.array(blocSchema),\n})\n\nexport const defaults = {\n  text: { schema: textMessageSchema },\n  markdown: { schema: markdownMessageSchema },\n  image: { schema: imageMessageSchema },\n  audio: { schema: audioMessageSchema },\n  video: { schema: videoMessageSchema },\n  file: { schema: fileMessageSchema },\n  location: { schema: locationMessageSchema },\n  carousel: { schema: carouselSchema },\n  card: { schema: cardSchema },\n  dropdown: { schema: choiceSchema },\n  choice: { schema: choiceSchema },\n  bloc: { schema: blocsSchema },\n} as const // should use satisfies operator but this works for older versions of TS\n", "import { z, type UIComponentDefinitions, type DefaultComponentDefinitions } from '@bpinternal/zui'\nexport * from '@bpinternal/zui'\n\nconst commonInputParams = z.object({\n  allowDynamicVariable: z.boolean().optional(),\n  horizontal: z.boolean().optional(),\n})\n\nexport const studioComponentDefinitions = {\n  string: {\n    text: {\n      id: 'text',\n      params: commonInputParams.extend({\n        multiLine: z.boolean().optional(),\n        growVertically: z.boolean().optional(),\n        suggestions: z.array(z.string()).optional(),\n      }),\n    },\n    dropdown: {\n      id: 'dropdown',\n      params: commonInputParams.extend({\n        filterable: z.boolean().optional(),\n      }),\n    },\n    radiogroup: {\n      id: 'radiogroup',\n      params: commonInputParams.extend({}),\n    },\n    date: {\n      id: 'date',\n      params: commonInputParams.extend({\n        dateFormat: z.string().optional(),\n        minDate: z.string().optional(),\n        maxDate: z.string().optional(),\n        defaultTimezone: z.string().optional(),\n        disableTimezoneSelection: z.boolean().optional(),\n        highlightCurrentDay: z.boolean().optional(),\n        showShortcutButtons: z.boolean().optional(),\n        showOutsideDaysOfMonth: z.boolean().optional(),\n        firstDayOfWeek: z.number().optional(),\n        canChangeMonth: z.boolean().optional(),\n        showWeekNumbers: z.boolean().optional(),\n      }),\n    },\n    time: {\n      id: 'time',\n      params: commonInputParams.extend({\n        useAMPM: z.boolean().optional(),\n        timeFormat: z.string().optional(),\n        minTime: z.string().optional(),\n        maxTime: z.string().optional(),\n        showArrowButtons: z.boolean().optional(),\n        precision: z.enum(['minute', 'second', 'millisecond']).optional(),\n      }),\n    },\n    richtext: {\n      id: 'richtext',\n      params: z.object({\n        allowDynamicVariable: z.boolean().optional(),\n        resizable: z.boolean().optional(),\n      }),\n    },\n    json: {\n      id: 'json',\n      params: commonInputParams.extend({\n        showPreview: z.boolean().optional(),\n        showValidationError: z.boolean().optional(),\n      }),\n    },\n    file: {\n      id: 'file',\n      params: commonInputParams.extend({\n        fileTypes: z.array(z.enum(['image', 'audio', 'video'])).optional(),\n        showUploadedFiles: z.boolean().optional(),\n      }),\n    },\n  },\n  number: {\n    number: {\n      id: 'number',\n      params: commonInputParams.extend({\n        allowNumericCharactersOnly: z.boolean().optional(),\n        stepSize: z.number().optional(),\n      }),\n    },\n    slider: {\n      id: 'slider',\n      params: z.object({\n        horizontal: z.boolean().optional(),\n        stepSize: z.number().optional(),\n      }),\n    },\n  },\n  boolean: {\n    switch: {\n      id: 'switch',\n      params: commonInputParams,\n    },\n  },\n  array: {\n    options: {\n      id: 'options',\n      params: commonInputParams,\n    },\n    strings: {\n      id: 'strings',\n      params: commonInputParams,\n    },\n    daterange: {\n      id: 'daterange',\n      params: z.object({\n        dateFormat: z.string().optional(),\n        minDate: z.string().optional(),\n        maxDate: z.string().optional(),\n        defaultTimezone: z.string().optional(),\n        allowSingleDayRange: z.boolean().optional(),\n        highlightCurrentDay: z.boolean().optional(),\n        showOutsideDaysOfMonth: z.boolean().optional(),\n        firstDayOfWeek: z.number().optional(),\n        canChangeMonth: z.boolean().optional(),\n        showWeekNumbers: z.boolean().optional(),\n      }),\n    },\n  },\n  object: {\n    collapsible: {\n      id: 'collapsible',\n      params: z.object({\n        defaultOpen: z.boolean().optional(),\n      }),\n    },\n    modal: {\n      id: 'modal',\n      params: z.object({\n        title: z.string().optional(),\n        buttonLabel: z.string().optional(),\n        closeButtonLabel: z.string().optional(),\n      }),\n    },\n    popover: {\n      id: 'popover',\n      params: z.object({\n        buttonLabel: z.string().optional(),\n      }),\n    },\n  },\n  discriminatedUnion: {},\n} as const satisfies UIComponentDefinitions\n\nexport type UI<Namespace extends 'studio' | 'dashboard' = 'studio'> = Namespace extends 'studio'\n  ? typeof studioComponentDefinitions\n  : Namespace extends 'dashboard'\n  ? DefaultComponentDefinitions\n  : any\n\nexport type GenericZuiSchema<\n  A extends Record<string, z.ZodTypeAny> = Record<string, z.ZodTypeAny>,\n  R extends z.ZodTypeAny = z.ZodTypeAny\n> = (typeArguments: A) => R\n\nexport default z\n", "export * from './llm'\nexport * from './text-to-image'\nexport * from './speech-to-text'\nexport * as schemas from './schemas'\nexport * from './sync'\n", "export const unique = <T>(array: T[]): T[] => Array.from(new Set(array))\nexport const pairs = <K extends string, V>(obj: Record<K, V>) => Object.entries(obj) as [K, V][]\nexport const values = <K extends string, V>(obj: Record<K, V>) => Object.values(obj) as V[]\nexport const mapValues = <K extends string, V, R>(obj: Record<K, V>, fn: (value: V, key: K) => R): Record<K, R> =>\n  Object.fromEntries(pairs(obj).map(([key, value]) => [key, fn(value, key)])) as Record<K, R>\n\nexport const mergeRecords = <K extends string, V>(\n  a: Record<K, V>,\n  b: Record<K, V>,\n  merge: (v1: V, v2: V) => V\n): Record<K, V> => {\n  const keys = unique([...Object.keys(a), ...Object.keys(b)]) as K[]\n  const result: Record<K, V> = {} as Record<K, V>\n  for (const key of keys) {\n    const aValue = a[key]\n    const bValue = b[key]\n    if (aValue && bValue) {\n      result[key] = merge(aValue, bValue)\n    } else if (aValue) {\n      result[key] = aValue\n    } else if (bValue) {\n      result[key] = bValue\n    }\n  }\n  return result\n}\n", "import * as utils from '../../utils'\nimport { z } from '../../zui'\n\nconst schemaName = Symbol('schemaName')\n\ntype BaseSchemas = Record<string, z.ZodSchema>\n\nexport type SchemaStoreProps<TSchemas extends BaseSchemas = BaseSchemas> = {\n  [K in keyof TSchemas]: {\n    schema: TSchemas[K]\n  }\n}\n\nexport type BrandedSchema<TSchema extends BaseSchemas[string] = BaseSchemas[string]> = {\n  schema: TSchema\n  [schemaName]: string\n}\n\nexport type SchemaStore<TSchemas extends BaseSchemas = BaseSchemas> = {\n  [K in keyof TSchemas]: BrandedSchema<TSchemas[K]>\n}\n\nexport const createStore = <TSchemas extends BaseSchemas>(\n  props: SchemaStoreProps<TSchemas> | undefined\n): SchemaStore<TSchemas> => {\n  if (!props) {\n    return {} as SchemaStore<TSchemas>\n  }\n  const store: SchemaStore<BaseSchemas> = utils.mapValues(props, (e, k) => ({ ...e, [schemaName]: k }))\n  return store as SchemaStore<TSchemas>\n}\n\nexport const isBranded = (schema: BrandedSchema): boolean => {\n  return schema[schemaName] !== undefined\n}\n\nexport const getName = (schema: BrandedSchema): string => {\n  return schema[schemaName]\n}\n", "import { Writable } from '../../type-utils'\nimport * as utils from '../../utils'\nimport { z } from '../../zui'\nimport { SchemaStore, BrandedSchema, createStore, isBranded, getName } from './branded-schema'\nimport { BaseConfig, BaseEvents, BaseActions, BaseChannels, BaseStates, BaseEntities } from './generic'\nimport { InterfaceDeclaration, InterfaceResolveInput } from './interface-declaration'\nimport {\n  ConfigurationDefinition,\n  EventDefinition,\n  ChannelDefinition,\n  ActionDefinition,\n  StateDefinition,\n  UserDefinition,\n  SecretDefinition,\n  EntityDefinition,\n  MessageDefinition,\n  InterfaceImplementationStatement,\n} from './types'\n\nexport type IntegrationDefinitionProps<\n  TConfig extends BaseConfig = BaseConfig,\n  TEvents extends BaseEvents = BaseEvents,\n  TActions extends BaseActions = BaseActions,\n  TChannels extends BaseChannels = BaseChannels,\n  TStates extends BaseStates = BaseStates,\n  TEntities extends BaseEntities = BaseEntities\n> = {\n  name: string\n  version: string\n\n  title?: string\n  description?: string\n  icon?: string\n  readme?: string\n\n  identifier?: {\n    extractScript?: string\n    fallbackHandlerScript?: string\n  }\n\n  configuration?: ConfigurationDefinition<TConfig>\n  events?: { [K in keyof TEvents]: EventDefinition<TEvents[K]> }\n\n  actions?: {\n    [K in keyof TActions]: ActionDefinition<TActions[K]>\n  }\n\n  channels?: {\n    [K in keyof TChannels]: ChannelDefinition<TChannels[K]>\n  }\n\n  states?: {\n    [K in keyof TStates]: StateDefinition<TStates[K]>\n  }\n\n  user?: UserDefinition\n\n  secrets?: Record<string, SecretDefinition>\n\n  entities?: {\n    [K in keyof TEntities]: EntityDefinition<TEntities[K]>\n  }\n}\n\ntype InterfaceTypeArguments<TInterfaceEntities extends BaseEntities> = {\n  [K in keyof TInterfaceEntities]: BrandedSchema<z.ZodSchema<z.infer<TInterfaceEntities[K]>>>\n}\n\ntype ExtensionBuilder<TIntegrationEntities extends BaseEntities, TInterfaceEntities extends BaseEntities> = (\n  input: SchemaStore<TIntegrationEntities>\n) => InterfaceTypeArguments<TInterfaceEntities>\n\nexport class IntegrationDefinition<\n  TConfig extends BaseConfig = BaseConfig,\n  TEvents extends BaseEvents = BaseEvents,\n  TActions extends BaseActions = BaseActions,\n  TChannels extends BaseChannels = BaseChannels,\n  TStates extends BaseStates = BaseStates,\n  TEntities extends BaseEntities = BaseEntities\n> {\n  public readonly name: this['props']['name']\n  public readonly version: this['props']['version']\n  public readonly title: this['props']['title']\n  public readonly description: this['props']['description']\n  public readonly icon: this['props']['icon']\n  public readonly readme: this['props']['readme']\n  public readonly configuration: this['props']['configuration']\n  public readonly events: this['props']['events']\n  public readonly actions: this['props']['actions']\n  public readonly channels: this['props']['channels']\n  public readonly states: this['props']['states']\n  public readonly user: this['props']['user']\n  public readonly secrets: this['props']['secrets']\n  public readonly identifier: this['props']['identifier']\n  public readonly entities: this['props']['entities']\n\n  public readonly interfaces: Record<string, InterfaceImplementationStatement> = {}\n\n  public constructor(\n    public readonly props: IntegrationDefinitionProps<TConfig, TEvents, TActions, TChannels, TStates, TEntities>\n  ) {\n    this.name = props.name\n    this.version = props.version\n    this.icon = props.icon\n    this.readme = props.readme\n    this.title = props.title\n    this.identifier = props.identifier\n    this.description = props.description\n    this.configuration = props.configuration\n    this.events = props.events\n    this.actions = props.actions\n    this.channels = props.channels\n    this.states = props.states\n    this.user = props.user\n    this.secrets = props.secrets\n    this.entities = props.entities\n  }\n\n  public clone(\n    props: Partial<IntegrationDefinitionProps<TConfig, TEvents, TActions, TChannels, TStates, TEntities>>\n  ): IntegrationDefinition<TConfig, TEvents, TActions, TChannels, TStates, TEntities> {\n    const clone = new IntegrationDefinition<TConfig, TEvents, TActions, TChannels, TStates, TEntities>({\n      ...this,\n      ...props,\n    })\n    for (const [key, value] of Object.entries(this.interfaces)) {\n      clone.interfaces[key] = value\n    }\n    return clone\n  }\n\n  public extend<E extends BaseEntities>(\n    interfaceDeclaration: InterfaceDeclaration<E>,\n    builder: ExtensionBuilder<TEntities, E>\n  ): this {\n    const extensionBuilderOutput = builder(createStore(this.entities))\n    const unbrandedEntity = utils.pairs(extensionBuilderOutput).find(([_k, e]) => !isBranded(e))\n    if (unbrandedEntity) {\n      // this means the user tried providing a plain schema without referencing an entity from the integration\n      throw new Error(\n        `Cannot extend interface \"${interfaceDeclaration.name}\" with entity \"${unbrandedEntity[0]}\"; the provided schema is not part of the integration's entities.`\n      )\n    }\n\n    const interfaceTypeArguments = utils.mapValues(extensionBuilderOutput, (e) => ({\n      name: getName(e),\n      schema: e.schema,\n    }))\n\n    const { resolved, implementStatement } = interfaceDeclaration.resolve({\n      entities: interfaceTypeArguments as InterfaceResolveInput<E>['entities'],\n    })\n\n    const self = this as Writable<IntegrationDefinition>\n\n    /**\n     * If an action is defined both in the integration and the interface; we merge both.\n     * This allows setting more specific properties in the integration, while staying compatible with the interface.\n     * Same goes for channels and events.\n     */\n\n    self.actions = utils.mergeRecords(self.actions ?? {}, resolved.actions, this._mergeActions)\n    self.channels = utils.mergeRecords(self.channels ?? {}, resolved.channels, this._mergeChannels)\n    self.events = utils.mergeRecords(self.events ?? {}, resolved.events, this._mergeEvents)\n\n    const entityNames = Object.values(interfaceTypeArguments).map((e) => e.name)\n    const key = `${interfaceDeclaration.name}<${entityNames.join(',')}>`\n    this.interfaces[key] = implementStatement\n\n    return this\n  }\n\n  private _mergeActions = (a: ActionDefinition, b: ActionDefinition): ActionDefinition => {\n    return {\n      title: b.title ?? a.title,\n      description: b.description ?? a.description,\n      input: {\n        schema: a.input.schema.merge(b.input.schema),\n      },\n      output: {\n        schema: a.output.schema.merge(b.output.schema),\n      },\n    }\n  }\n\n  private _mergeEvents = (a: EventDefinition, b: EventDefinition): EventDefinition => {\n    return {\n      title: b.title ?? a.title,\n      description: b.description ?? a.description,\n      schema: a.schema.merge(b.schema),\n    }\n  }\n\n  private _mergeChannels = (a: ChannelDefinition, b: ChannelDefinition): ChannelDefinition => {\n    const messages = utils.mergeRecords(a.messages, b.messages, this._mergeMessage)\n    return {\n      title: b.title ?? a.title,\n      description: b.description ?? a.description,\n      conversation: b.conversation ?? a.conversation,\n      message: b.message ?? a.message,\n      messages,\n    }\n  }\n\n  private _mergeMessage = (a: MessageDefinition, b: MessageDefinition): MessageDefinition => {\n    return {\n      schema: a.schema.merge(b.schema),\n    }\n  }\n}\n", "import * as utils from '../../utils'\nimport z, { AnyZodObject, GenericZuiSchema, ZodRef } from '../../zui'\nimport { BaseActions, BaseChannels, BaseEntities, BaseEvents } from './generic'\nimport {\n  ActionDefinition,\n  ChannelDefinition,\n  EntityDefinition,\n  EventDefinition,\n  InterfaceImplementationStatement,\n  ResolvedInterface,\n} from './types'\n\ntype EntityReferences<TEntities extends BaseEntities> = {\n  [K in keyof TEntities]: ZodRef\n}\n\ntype GenericEventDefinition<TEntities extends BaseEntities, TEvent extends BaseEvents[string] = BaseEvents[string]> = {\n  schema: GenericZuiSchema<EntityReferences<TEntities>, TEvent>\n}\n\ntype GenericChannelDefinition<\n  TEntities extends BaseEntities,\n  TChannel extends BaseChannels[string] = BaseChannels[string]\n> = {\n  messages: {\n    [K in keyof TChannel]: {\n      schema: GenericZuiSchema<EntityReferences<TEntities>, TChannel[K]>\n    }\n  }\n}\n\ntype GenericActionDefinition<\n  TEntities extends BaseEntities,\n  TAction extends BaseActions[string] = BaseActions[string]\n> = {\n  input: { schema: GenericZuiSchema<EntityReferences<TEntities>, TAction> }\n  output: { schema: GenericZuiSchema<EntityReferences<TEntities>, AnyZodObject> }\n}\n\nexport type InterfaceTemplateNameProps<TEntities extends BaseEntities = BaseEntities> = {\n  [K in keyof TEntities]: string\n}\n\nexport type InterfaceDeclarationProps<\n  TEntities extends BaseEntities = BaseEntities,\n  TActions extends BaseActions = BaseActions,\n  TEvents extends BaseEntities = BaseEntities,\n  TChannels extends BaseChannels = BaseChannels\n> = {\n  name: string\n  version: string\n\n  entities?: {\n    [K in keyof TEntities]: EntityDefinition<TEntities[K]>\n  }\n\n  events?: { [K in keyof TEvents]: GenericEventDefinition<TEntities, TEvents[K]> }\n\n  actions?: {\n    [K in keyof TActions]: GenericActionDefinition<TEntities, TActions[K]>\n  }\n\n  channels?: {\n    [K in keyof TChannels]: GenericChannelDefinition<TEntities, TChannels[K]>\n  }\n\n  templateName?: (name: string, props: InterfaceTemplateNameProps<TEntities>) => string\n}\n\nexport type InterfaceResolveInput<TEntities extends BaseEntities = BaseEntities> = {\n  entities: {\n    [K in keyof TEntities]: {\n      name: string\n      schema: TEntities[K]\n    }\n  }\n}\n\nexport type InterfaceResolveOutput<\n  TActions extends BaseActions = BaseActions,\n  TEvents extends BaseEvents = BaseEvents\n> = {\n  resolved: ResolvedInterface<TActions, TEvents>\n  implementStatement: InterfaceImplementationStatement\n}\n\nexport class InterfaceDeclaration<\n  TEntities extends BaseEntities = BaseEntities,\n  TActions extends BaseActions = BaseActions,\n  TEvents extends BaseEvents = BaseEvents\n> {\n  public readonly name: this['props']['name']\n  public readonly version: this['props']['version']\n  public readonly entities: NonNullable<this['props']['entities']>\n  public readonly events: NonNullable<this['props']['events']>\n  public readonly actions: NonNullable<this['props']['actions']>\n  public readonly channels: NonNullable<this['props']['channels']>\n  public readonly templateName: this['props']['templateName']\n\n  public constructor(public readonly props: InterfaceDeclarationProps<TEntities, TActions, TEvents>) {\n    this.name = props.name\n    this.version = props.version\n    this.entities = props.entities ?? ({} as NonNullable<this['props']['entities']>)\n    this.events = props.events ?? ({} as NonNullable<this['props']['events']>)\n    this.actions = props.actions ?? ({} as NonNullable<this['props']['actions']>)\n    this.channels = props.channels ?? ({} as NonNullable<this['props']['channels']>)\n\n    this.templateName = props.templateName\n  }\n\n  public resolve(props: InterfaceResolveInput<TEntities>): InterfaceResolveOutput<TActions, TEvents> {\n    const { entities } = props\n\n    const implementStatement: InterfaceImplementationStatement = {\n      name: this.name,\n      version: this.version,\n      entities: utils.mapValues(entities, (entity) => ({ name: entity.name })), // { item: { name: 'issue' } }\n      actions: {},\n      events: {},\n    }\n\n    const actions: Record<string, ActionDefinition> = {}\n    const events: Record<string, EventDefinition> = {}\n    const channels: Record<string, ChannelDefinition> = {}\n\n    // dereference actions\n    for (const [actionName, action] of utils.pairs(this.actions)) {\n      const resolvedInputSchema = this._dereference(action.input.schema, entities)\n      const resolvedOutputSchema = this._dereference(action.output.schema, entities)\n\n      const newActionName = this._rename(entities, actionName)\n      actions[newActionName] = {\n        input: { schema: resolvedInputSchema },\n        output: { schema: resolvedOutputSchema },\n      }\n      implementStatement.actions[actionName] = { name: newActionName }\n    }\n\n    // dereference events\n    for (const [eventName, event] of utils.pairs(this.events)) {\n      const resolvedEventSchema = this._dereference(event.schema, entities)\n      const newEventName = this._rename(entities, eventName)\n      events[newEventName] = { schema: resolvedEventSchema }\n      implementStatement.events[eventName] = { name: newEventName }\n    }\n\n    // dereference channels\n    for (const [channelName, channel] of utils.pairs(this.channels)) {\n      const messages: Record<string, { schema: AnyZodObject }> = {}\n      for (const [messageName, message] of utils.pairs(channel.messages)) {\n        const resolvedMessageSchema = this._dereference(message.schema, entities)\n        messages[messageName] = { schema: resolvedMessageSchema }\n      }\n      channels[channelName] = { messages }\n    }\n\n    const resolved = {\n      actions: actions as ResolvedInterface<TActions, TEvents>['actions'],\n      events: events as ResolvedInterface<TActions, TEvents>['events'],\n      channels: channels as ResolvedInterface<TActions, TEvents>['channels'],\n    }\n\n    return {\n      resolved,\n      implementStatement,\n    }\n  }\n\n  private _dereference(\n    generic: GenericZuiSchema<EntityReferences<TEntities>, AnyZodObject>,\n    entities: InterfaceResolveInput<TEntities>['entities']\n  ): AnyZodObject {\n    const entitySchemas: Record<string, AnyZodObject> = {}\n    const entityReferences: Record<string, ZodRef> = {}\n    for (const [entityName, entity] of utils.pairs(entities)) {\n      entitySchemas[entityName] = entity.schema\n      entityReferences[entityName] = z.ref(entityName)\n    }\n    return generic(entityReferences as EntityReferences<TEntities>).dereference(\n      entitySchemas as TEntities\n    ) as AnyZodObject\n  }\n\n  private _rename(entities: InterfaceResolveInput<TEntities>['entities'], name: string): string {\n    if (!this.templateName) {\n      return name\n    }\n\n    const templateProps = utils.mapValues(entities, (entity) => entity.name) as Record<keyof TEntities, string>\n    return this.templateName(name, templateProps)\n  }\n}\n", "import { InterfaceDeclaration } from '../integration/definition'\nimport z from '../zui'\n\nconst ToolCallSchema = z.object({\n  id: z.string(),\n  type: z.enum(['function']),\n  function: z.object({\n    name: z.string(),\n    arguments: z\n      .record(z.any())\n      .nullable()\n      .describe('Some LLMs may generate invalid JSON for a tool call, so this will be `null` when it happens.'),\n  }),\n})\n\nconst ToolChoiceSchema = z.object({\n  // TODO: remove empty value from enum once Studio issue is fixed\n  type: z.enum(['auto', 'specific', 'any', 'none', '']).optional(), // note: Claude doesn't support \"none\" but we can simply strip out the tools when `type` is \"none\"\n  functionName: z.string().optional().describe('Required if `type` is \"specific\"'),\n})\n\nconst MessageSchema = z.object({\n  role: z.enum(['user', 'assistant']),\n  type: z.enum(['text', 'tool_calls', 'tool_result', 'multipart']).default('text'),\n  toolCalls: z.array(ToolCallSchema).optional().describe('Required if `type` is \"tool_calls\"'),\n  toolResultCallId: z.string().optional().describe('Required if `type` is \"tool_result\"'), // note: not supported by Gemini\n  content: z\n    .string()\n    // TODO: union types are not supported yet by the Studio, comment this out when testing via an action card in the Studio\n    .or(\n      z.array(\n        z.object({\n          type: z.enum(['text', 'image']),\n          mimeType: z\n            .string()\n            .optional()\n            .describe(\n              'Indicates the MIME type of the content. If not provided it will be detected from the content-type header of the provided URL.'\n            ),\n          text: z.string().optional().describe('Required if part type is \"text\" '),\n          url: z.string().optional().describe('Required if part type is \"image\"'),\n        })\n      )\n    )\n    .optional()\n    .nullable()\n    .describe(\n      'Required unless `type` is \"tool_call\". If `type` is \"multipart\", this field must be an array of content objects. If `type` is \"tool_result\" then this field should be the result of the tool call (a plain string or a JSON-encoded array or object). If `type` is \"tool_call\" then the `toolCalls` field should be used instead.'\n    ),\n})\n\nconst ModelRefSchema = z.object({ id: z.string() })\n\nconst ModelSchema = ModelRefSchema.extend({\n  name: z.string(),\n  input: z.object({\n    maxTokens: z.number().int(),\n    costPer1MTokens: z.number().describe('Cost per 1 million tokens, in U.S. dollars'),\n  }),\n  output: z.object({\n    maxTokens: z.number().int(),\n    costPer1MTokens: z.number().describe('Cost per 1 million tokens, in U.S. dollars'),\n  }),\n})\n\nconst GenerateContentInputSchema = <S extends z.ZodSchema>(modelRefSchema: S) =>\n  z.object({\n    model: modelRefSchema.describe('Model to use for content generation').optional(),\n    systemPrompt: z.string().optional().describe('Optional system prompt to guide the model'),\n    messages: z.array(MessageSchema).describe('Array of messages for the model to process'),\n    responseFormat: z\n      .enum(['text', 'json_object'])\n      .optional()\n      .describe(\n        'Response format expected from the model. If \"json_object\" is chosen, you must instruct the model to generate JSON either via the system prompt or a user message.'\n      ), // note: only OpenAI and Groq support this but for other models we can just append this as an indication in the system prompt\n    // note: we don't support streaming yet\n    maxTokens: z.number().optional().describe('Maximum number of tokens allowed in the generated response'),\n    temperature: z\n      .number()\n      .min(0)\n      .max(2)\n      // @ts-ignore\n      .displayAs({ id: 'slider', params: { stepSize: 0.01, horizontal: true } })\n      .default(1)\n      .describe('Sampling temperature for the model. Higher values result in more random outputs.'),\n    topP: z\n      .number()\n      .min(0)\n      .max(1)\n      .default(1)\n      // @ts-ignore\n      .displayAs({ id: 'slider', params: { stepSize: 0.01, horizontal: true } })\n      .describe(\n        'Top-p sampling parameter. Limits sampling to the smallest set of tokens with a cumulative probability above the threshold.'\n      ), // TODO: .placeholder() from zui doesn't work, so we have to use .default() which introduces some typing issues\n    // note: topK is supported by Claude and Gemini but not by OpenAI or Groq\n    stopSequences: z\n      .array(z.string())\n      .max(4)\n      .optional()\n      .describe('Sequences where the model should stop generating further tokens.'),\n    tools: z\n      .array(\n        z.object({\n          type: z.literal('function'),\n          function: z.object({\n            name: z.string().describe('Function name'),\n            description: z.string().optional(),\n            argumentsSchema: z.object({}).passthrough().optional().describe('JSON schema of the function arguments'),\n          }),\n        })\n      )\n      .optional(),\n    // TODO: an object with options doesn't seem to be supported by the Studio as it's not rendering correctly, the dropdown for \"type\" is not working and it's sending a blank value instead which causes a schema validation error unless an empty value is allowed in the `type` enum\n    toolChoice: ToolChoiceSchema.optional(), // note: Gemini doesn't support this but we can just ignore it there\n    userId: z.string().optional(),\n    debug: z.boolean().optional().describe('Set to `true` to output debug information to the bot logs'),\n  })\n\nconst GenerateContentInputBaseSchema = GenerateContentInputSchema(ModelRefSchema)\n\nconst GenerateContentOutputSchema = z.object({\n  id: z.string().describe('Response ID from LLM provider'),\n  provider: z.string().describe('LLM provider name'),\n  model: z.string().describe('Model name'),\n  choices: z.array(\n    MessageSchema.omit({ role: true }).extend({\n      role: z.literal('assistant'),\n      index: z.number().int(),\n      stopReason: z.enum(['stop', 'max_tokens', 'tool_calls', 'content_filter', 'other']),\n      // note: stopSequence is supported by Claude but not by OpenAI, Groq or Gemini\n    })\n  ),\n  usage: z.object({\n    inputTokens: z.number().int().describe('Number of input tokens used by the model'),\n    inputCost: z.number().describe('Cost of the input tokens received by the model, in U.S. dollars'),\n    outputTokens: z.number().int().describe('Number of output tokens used by the model'),\n    outputCost: z.number().describe('Cost of the output tokens generated by the model, in U.S. dollars'),\n  }),\n})\n\nexport const llm = new InterfaceDeclaration({\n  name: 'llm',\n  version: '3.1.0',\n  entities: {\n    modelRef: {\n      schema: ModelRefSchema,\n    },\n  },\n  events: {},\n  actions: {\n    generateContent: {\n      input: {\n        schema: ({ modelRef }) => GenerateContentInputSchema(modelRef),\n      },\n      output: {\n        schema: () => GenerateContentOutputSchema,\n      },\n    },\n    listLanguageModels: {\n      input: {\n        schema: () => z.object({}),\n      },\n      output: {\n        schema: ({ modelRef }) =>\n          z.object({\n            models: z.array(z.intersection(ModelSchema, modelRef)),\n          }),\n      },\n    },\n  },\n})\n\nexport namespace llm {\n  export type GenerateContentInput = z.infer<typeof GenerateContentInputBaseSchema>\n  export type GenerateContentOutput = z.infer<typeof GenerateContentOutputSchema>\n  export type ToolCall = z.infer<typeof ToolCallSchema>\n  export type Message = z.infer<typeof MessageSchema>\n  export type Model = z.infer<typeof ModelSchema>\n  export type ModelDetails = Omit<Model, 'id'>\n}\n", "import { InterfaceDeclaration } from '../integration/definition'\nimport z from '../zui'\n\nconst ImageModelRefSchema = z.object({\n  id: z.string(),\n})\n\nconst ImageModelSchema = ImageModelRefSchema.extend({\n  name: z.string(),\n  costPerImage: z.number().describe('Cost per image generation, in U.S. dollars'),\n  sizes: z.array(z.string()).describe('Available image sizes'),\n  defaultSize: z.string().describe('Default image size generated by model'),\n})\n\nconst ImageGenerationParamsSchema = z.object({}).describe('Model-specific parameters for image generation')\n\nconst GenerateImageInputSchema = <TModelRef extends z.ZodSchema, TParams extends z.ZodSchema>(\n  imageModelRefSchema: TModelRef,\n  paramsSchema: TParams\n) =>\n  z.object({\n    model: imageModelRefSchema.optional().describe('Model to use for image generation'),\n    prompt: z.string(),\n    size: z.string().optional(),\n    params: paramsSchema.optional(),\n  })\n\nconst GenerateContentInputBaseSchema = GenerateImageInputSchema(ImageModelRefSchema, ImageGenerationParamsSchema)\n\nconst GenerateImageOutputSchema = z.object({\n  model: z.string().describe('Model name used'),\n  imageUrl: z.string().describe('Temporary URL of generated image'),\n  cost: z.number().describe('Cost of the image generation, in U.S. dollars'),\n})\n\nexport const textToImage = new InterfaceDeclaration({\n  name: 'textToImage',\n  version: '1.0.0',\n  entities: {\n    imageModelRef: {\n      schema: ImageModelRefSchema,\n    },\n    imageGenerationParams: {\n      schema: ImageGenerationParamsSchema,\n    },\n  },\n  actions: {\n    generateImage: {\n      input: {\n        schema: ({ imageModelRef, imageGenerationParams }) =>\n          GenerateImageInputSchema(imageModelRef, imageGenerationParams),\n      },\n      output: {\n        schema: () => GenerateImageOutputSchema,\n      },\n    },\n    listImageModels: {\n      input: {\n        schema: () => z.object({}),\n      },\n      output: {\n        schema: ({ imageModelRef }) =>\n          z.object({\n            models: z.array(z.intersection(ImageModelSchema, imageModelRef)),\n          }),\n      },\n    },\n  },\n})\n\nexport namespace textToImage {\n  export type GenerateImageInputSchema = z.infer<typeof GenerateContentInputBaseSchema>\n  export type GenerateImageOutputSchema = z.infer<typeof GenerateImageOutputSchema>\n  export type ImageModel = z.infer<typeof ImageModelSchema>\n  export type ImageModelDetails = Omit<ImageModel, 'id'>\n}\n", "import z from '../../zui'\n\nexport const OpenAITranscribeAudioOutputSchema = z.object({\n  language: z.string().describe('Detected language of the audio'),\n  duration: z.number().describe('Duration of the audio file, in seconds'),\n  segments: z.array(\n    z.object({\n      text: z.string().describe('Text content of the segment.'),\n      id: z.number().describe('Unique identifier of the segment'),\n      seek: z.number().describe('Seek offset of the segment'),\n      start: z.number().describe('Start time of the segment in seconds.'),\n      end: z.number().describe('End time of the segment in seconds.'),\n      tokens: z.array(z.number()).describe('Array of token IDs for the text content.'),\n      temperature: z.number().describe('Temperature parameter used for generating the segment.'),\n      avg_logprob: z\n        .number()\n        .describe('Average logprob of the segment. If the value is lower than -1, consider the logprobs failed.'),\n      compression_ratio: z\n        .number()\n        .describe(\n          'Compression ratio of the segment. If the value is greater than 2.4, consider the compression failed.'\n        ),\n      no_speech_prob: z\n        .number()\n        .describe(\n          'Probability of no speech in the segment. If the value is higher than 1.0 and the avg_logprob is below -1, consider this segment silent.'\n        ),\n    })\n  ),\n})\n", "import { InterfaceDeclaration } from '../integration/definition'\nimport z from '../zui'\nimport { OpenAITranscribeAudioOutputSchema } from './schemas/speech-to-text'\n\nconst SpeechModelRefSchema = z.object({\n  id: z.string(),\n})\n\nconst SpeechToTextModelSchema = SpeechModelRefSchema.extend({\n  name: z.string(),\n  costPerMinute: z.number().describe('Cost per minute of speech transcription, in U.S. dollars'),\n})\n\nconst TranscribeAudioInputSchema = <TModelRef extends z.ZodSchema>(imageModelRefSchema: TModelRef) =>\n  z.object({\n    model: imageModelRefSchema.optional().describe('Model to use for speech-to-text transcription (optional)'),\n    fileUrl: z\n      .string()\n      .url()\n      .describe(\n        'URL of the audio file to transcribe. The URL should return a content-type header in order to detect the audio format. Supported audio formats supported are: mp3, mp4, mpeg, mpga, m4a, wav, webm'\n      ),\n    language: z\n      .string()\n      .optional()\n      .describe(\n        'The language of the input audio (optional). Supplying the input language in ISO-639-1 format will improve accuracy and latency.'\n      ),\n    prompt: z\n      .string()\n      .optional()\n      .describe(\n        \"An optional text to guide the model's style or continue a previous audio segment. The prompt should match the audio language.\"\n      ),\n    temperature: z\n      .number()\n      .default(0)\n      .optional()\n      .describe(\n        'The sampling temperature (optional), between 0 and 1. Defaults to 0 (automatic). Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.'\n      ),\n  })\n\nconst TranscribeAudioBaseSchema = TranscribeAudioInputSchema(SpeechModelRefSchema)\n\nconst TranscribeAudioOutputSchema = OpenAITranscribeAudioOutputSchema.extend({\n  model: z.string().describe('Model name used'),\n  cost: z.number().describe('Total cost of this transcription, in U.S. dollars'),\n})\n\nexport const speechToText = new InterfaceDeclaration({\n  name: 'speechToText',\n  version: '1.0.0',\n  entities: {\n    speechToTextModelRef: {\n      schema: SpeechModelRefSchema,\n    },\n  },\n  actions: {\n    transcribeAudio: {\n      input: {\n        schema: ({ speechToTextModelRef }) => TranscribeAudioInputSchema(speechToTextModelRef),\n      },\n      output: {\n        schema: () => TranscribeAudioOutputSchema,\n      },\n    },\n    listSpeechToTextModels: {\n      input: {\n        schema: () => z.object({}),\n      },\n      output: {\n        schema: ({ speechToTextModelRef }) =>\n          z.object({\n            models: z.array(z.intersection(SpeechToTextModelSchema, speechToTextModelRef)),\n          }),\n      },\n    },\n  },\n})\n\nexport namespace speechToText {\n  export type TranscribeAudioInputSchema = z.infer<typeof TranscribeAudioBaseSchema>\n  export type TranscribeAudioOutputSchema = z.infer<typeof TranscribeAudioOutputSchema>\n  export type SpeechToTextModel = z.infer<typeof SpeechToTextModelSchema>\n  export type SpeechToTextModelDetails = Omit<SpeechToTextModel, 'id'>\n}\n", "export * as speechToText from './speech-to-text'\n", "import { InterfaceDeclaration } from '../integration/definition'\nimport z from '../zui'\n\nconst baseItem = z.object({ id: z.string() })\nconst withId = (schema: z.ZodTypeAny) => z.intersection(schema, baseItem)\n\nconst capitalize = (s: string) => s[0]!.toUpperCase() + s.slice(1)\nconst camelCase = (...parts: string[]) => {\n  const [first, ...rest] = parts.filter((s) => s.length > 0).map((s) => s.toLowerCase())\n  if (!first) {\n    return ''\n  }\n  return [first, ...rest.map(capitalize)].join('')\n}\n\nconst nextToken = z.string().optional()\nexport const listable = new InterfaceDeclaration({\n  name: 'listable',\n  version: '0.0.1',\n  entities: {\n    item: {\n      schema: baseItem,\n    },\n  },\n  events: {},\n  actions: {\n    list: {\n      input: {\n        schema: () => z.object({ nextToken }),\n      },\n      output: {\n        schema: (args) =>\n          z.object({\n            items: z.array(withId(args.item)),\n            meta: z.object({ nextToken }),\n          }),\n      },\n    },\n  },\n  templateName: (name, props) => camelCase(props.item, name), // issueList\n})\n\nexport const creatable = new InterfaceDeclaration({\n  name: 'creatable',\n  version: '0.0.1',\n  entities: {\n    item: {\n      schema: baseItem,\n    },\n  },\n  events: {\n    created: {\n      schema: (args) =>\n        z.object({\n          item: withId(args.item),\n        }),\n    },\n  },\n  actions: {\n    create: {\n      input: {\n        schema: (args) => z.object({ item: args.item }),\n      },\n      output: {\n        schema: (args) => z.object({ item: withId(args.item) }),\n      },\n    },\n  },\n  templateName: (name, props) => camelCase(props.item, name), // issueCreate, issueCreated\n})\n\nexport const readable = new InterfaceDeclaration({\n  name: 'readable',\n  version: '0.0.1',\n  entities: {\n    item: {\n      schema: baseItem,\n    },\n  },\n  events: {},\n  actions: {\n    read: {\n      input: {\n        schema: () => baseItem,\n      },\n      output: {\n        schema: (args) => z.object({ item: withId(args.item) }),\n      },\n    },\n  },\n  templateName: (name, props) => camelCase(props.item, name), // issueRead\n})\n\nexport const updatable = new InterfaceDeclaration({\n  name: 'updatable',\n  version: '0.0.1',\n  entities: {\n    item: {\n      schema: baseItem,\n    },\n  },\n  events: {\n    updated: {\n      schema: (args) =>\n        z.object({\n          item: withId(args.item),\n        }),\n    },\n  },\n  actions: {\n    update: {\n      input: {\n        schema: (args) => baseItem.extend({ item: args.item }),\n      },\n      output: {\n        schema: (args) => z.object({ item: withId(args.item) }),\n      },\n    },\n  },\n  templateName: (name, props) => camelCase(props.item, name), // issueUpdate, issueUpdated\n})\n\nexport const deletable = new InterfaceDeclaration({\n  name: 'deletable',\n  version: '0.0.1',\n  entities: {\n    item: {\n      schema: baseItem,\n    },\n  },\n  events: {\n    deleted: {\n      schema: () => baseItem,\n    },\n  },\n  actions: {\n    delete: {\n      input: {\n        schema: () => baseItem,\n      },\n      output: {\n        schema: () => z.object({}),\n      },\n    },\n  },\n  templateName: (name, props) => camelCase(props.item, name), // issueDelete, issueDeleted\n})\n", "export const botIdHeader = 'x-bot-id'\nexport const botUserIdHeader = 'x-bot-user-id'\nexport const integrationIdHeader = 'x-integration-id'\nexport const webhookIdHeader = 'x-webhook-id'\n\nexport const configurationHeader = 'x-bp-configuration'\nexport const operationHeader = 'x-bp-operation'\nexport const typeHeader = 'x-bp-type'\n", "import { createServer, IncomingMessage, Server } from 'node:http'\nimport { log } from './log'\n\nexport type Request = {\n  body?: string\n  path: string\n  query: string\n  method: string\n  headers: { [key: string]: string | undefined }\n}\n\nexport type Response = {\n  body?: string\n  headers?: { [key: string]: string }\n  status?: number\n}\n\nexport type Handler = (req: Request) => Promise<Response | void>\n\nexport function parseBody<T>(req: Request): T {\n  if (!req.body) {\n    throw new Error('Missing body')\n  }\n  return JSON.parse(req.body)\n}\n\nexport async function serve(\n  handler: Handler,\n  port: number = 8072,\n  callback: (port: number) => void = defaultCallback\n): Promise<Server> {\n  /* eslint-disable @typescript-eslint/no-misused-promises */\n  const server = createServer(async (req, res) => {\n    try {\n      const request = await mapIncomingMessageToRequest(req)\n      if (request.path === '/health') {\n        res.writeHead(200).end('ok')\n        return\n      }\n      const response = await handler(request)\n      res.writeHead(response?.status ?? 200, response?.headers ?? {}).end(response?.body ?? '{}')\n    } catch (e: any) {\n      log.error('Error while handling request', { error: e?.message ?? 'Internal error occured' })\n      res.writeHead(500).end(JSON.stringify({ error: e?.message ?? 'Internal error occured' }))\n    }\n  })\n\n  server.listen(port, () => callback(port))\n  return server\n}\n\nasync function mapIncomingMessageToRequest(incoming: IncomingMessage): Promise<Request> {\n  const body = await readBody(incoming)\n  const headers = {} as Request['headers']\n\n  for (let i = 0; i < incoming.rawHeaders.length; i += 2) {\n    const key = incoming.rawHeaders[i]!.toLowerCase()\n    const value = incoming.rawHeaders[i + 1]!\n    headers[key] = value\n  }\n\n  const url = new URL(\n    incoming.url ?? '',\n    incoming.headers.host ? `http://${incoming.headers.host}` : 'http://botpress.cloud'\n  )\n\n  return {\n    body,\n    path: url.pathname,\n    query: trimPrefix(url.search, '?'),\n    headers,\n    method: incoming.method?.toUpperCase() ?? 'GET',\n  }\n}\n\nfunction trimPrefix(value: string, prefix: string) {\n  return value.indexOf(prefix) === 0 ? value.slice(prefix.length) : value\n}\n\nasync function readBody(incoming: IncomingMessage) {\n  return new Promise<string | undefined>((resolve, reject) => {\n    if (incoming.method !== 'POST' && incoming.method !== 'PUT' && incoming.method !== 'PATCH') {\n      return resolve(undefined)\n    }\n\n    let body = ''\n\n    incoming.on('data', (chunk) => (body += chunk.toString()))\n    incoming.on('error', (e) => reject(e))\n    incoming.on('end', () => resolve(body))\n  })\n}\n\nfunction defaultCallback(port: number) {\n  log.info(`Listening on port ${port}`)\n}\n", "export type Logger = {\n  debug(message: string, metadata?: any): void\n  info(message: string, metadata?: any): void\n  warn(message: string, metadata?: any): void\n  error(message: string, metadata?: any): void\n}\nexport const log: Logger = console\n", "import { z } from '@bpinternal/zui'\nimport {\n  botIdHeader,\n  botUserIdHeader,\n  configurationHeader,\n  integrationIdHeader,\n  operationHeader,\n  webhookIdHeader,\n} from '../const'\n\nexport const integrationOperationSchema = z.enum([\n  'webhook_received',\n  'message_created',\n  'action_triggered',\n  'register',\n  'unregister',\n  'ping',\n  'create_user',\n  'create_conversation',\n])\n\nexport type IntegrationOperation = z.infer<typeof integrationOperationSchema>\n\nexport type IntegrationContext<Configuration = any> = {\n  botId: string\n  botUserId: string\n  integrationId: string\n  webhookId: string\n  operation: IntegrationOperation\n  configuration: Configuration\n}\n\nexport const extractContext = (headers: Record<string, string | undefined>): IntegrationContext => {\n  const botId = headers[botIdHeader]\n  const botUserId = headers[botUserIdHeader]\n  const integrationId = headers[integrationIdHeader]\n  const webhookId = headers[webhookIdHeader]\n  const base64Configuration = headers[configurationHeader]\n  const operation = integrationOperationSchema.parse(headers[operationHeader])\n\n  if (!botId) {\n    throw new Error('Missing bot headers')\n  }\n\n  if (!botUserId) {\n    throw new Error('Missing bot user headers')\n  }\n\n  if (!integrationId) {\n    throw new Error('Missing integration headers')\n  }\n\n  if (!webhookId) {\n    throw new Error('Missing webhook headers')\n  }\n\n  if (!base64Configuration) {\n    throw new Error('Missing configuration headers')\n  }\n\n  if (!operation) {\n    throw new Error('Missing operation headers')\n  }\n\n  return {\n    botId,\n    botUserId,\n    integrationId,\n    webhookId,\n    operation,\n    configuration: base64Configuration ? JSON.parse(Buffer.from(base64Configuration, 'base64').toString('utf-8')) : {},\n  }\n}\n", "import { isApiError, Client, type Conversation, type Message, type User, RuntimeError } from '@botpress/client'\nimport { Request, Response, parseBody } from '../serve'\nimport { Cast, Merge } from '../type-utils'\nimport { IntegrationSpecificClient } from './client'\nimport { ToTags } from './client/types'\nimport { extractContext, type IntegrationContext } from './context'\nimport { BaseIntegration } from './generic'\nimport { IntegrationLogger, integrationLogger } from './logger'\n\ntype CommonArgs<TIntegration extends BaseIntegration> = {\n  ctx: IntegrationContext<TIntegration['configuration']>\n  client: IntegrationSpecificClient<TIntegration>\n  logger: IntegrationLogger\n}\n\ntype RegisterPayload = { webhookUrl: string }\ntype RegisterArgs<TIntegration extends BaseIntegration> = CommonArgs<TIntegration> & RegisterPayload\n\ntype UnregisterPayload = { webhookUrl: string }\ntype UnregisterArgs<TIntegration extends BaseIntegration> = CommonArgs<TIntegration> & UnregisterPayload\n\ntype WebhookPayload = { req: Request }\ntype WebhookArgs<TIntegration extends BaseIntegration> = CommonArgs<TIntegration> & WebhookPayload\n\ntype ActionPayload<T extends string, I> = { type: T; input: I }\ntype ActionArgs<TIntegration extends BaseIntegration, T extends string, I> = CommonArgs<TIntegration> &\n  ActionPayload<T, I>\n\ntype CreateUserPayload<TIntegration extends BaseIntegration> = {\n  tags: ToTags<keyof TIntegration['user']['tags']>\n}\n\ntype CreateUserArgs<TIntegration extends BaseIntegration> = CommonArgs<TIntegration> & CreateUserPayload<TIntegration>\n\ntype CreateConversationPayload<\n  TIntegration extends BaseIntegration,\n  TChannel extends keyof TIntegration['channels'] = keyof TIntegration['channels']\n> = {\n  channel: TChannel\n  tags: ToTags<keyof TIntegration['channels'][TChannel]['conversation']['tags']>\n}\n\ntype CreateConversationArgs<TIntegration extends BaseIntegration> = CommonArgs<TIntegration> &\n  CreateConversationPayload<TIntegration>\n\ntype MessagePayload<\n  TIntegration extends BaseIntegration,\n  TChannel extends keyof TIntegration['channels'],\n  TMessage extends keyof TIntegration['channels'][TChannel]['messages']\n> = {\n  type: TMessage\n  payload: TIntegration['channels'][TChannel]['messages'][TMessage]\n  conversation: Merge<\n    Conversation,\n    {\n      tags: ToTags<keyof TIntegration['channels'][TChannel]['conversation']['tags']>\n    }\n  >\n  message: Merge<\n    Message,\n    {\n      tags: ToTags<keyof TIntegration['channels'][TChannel]['message']['tags']>\n    }\n  >\n  user: Merge<\n    User,\n    {\n      tags: ToTags<keyof TIntegration['user']['tags']>\n    }\n  >\n}\n\ntype MessageArgs<\n  TIntegration extends BaseIntegration,\n  TChannel extends keyof TIntegration['channels'],\n  TMessage extends keyof TIntegration['channels'][TChannel]['messages']\n> = CommonArgs<TIntegration> &\n  MessagePayload<TIntegration, TChannel, TMessage> & {\n    ack: (props: { tags: ToTags<keyof TIntegration['channels'][TChannel]['message']['tags']> }) => Promise<void>\n  }\n\nexport type RegisterFunction<TIntegration extends BaseIntegration> = (\n  props: RegisterArgs<TIntegration>\n) => Promise<void>\n\nexport type UnregisterFunction<TIntegration extends BaseIntegration> = (\n  props: UnregisterArgs<TIntegration>\n) => Promise<void>\n\nexport type WebhookFunction<TIntegration extends BaseIntegration> = (\n  props: WebhookArgs<TIntegration>\n) => Promise<Response | void>\n\nexport type ActionFunctions<TIntegration extends BaseIntegration> = {\n  [ActionType in keyof TIntegration['actions']]: (\n    props: ActionArgs<TIntegration, Cast<ActionType, string>, TIntegration['actions'][ActionType]['input']>\n  ) => Promise<TIntegration['actions'][ActionType]['output']>\n}\n\nexport type CreateUserFunction<TIntegration extends BaseIntegration> = (\n  props: CreateUserArgs<TIntegration>\n) => Promise<Response | void>\n\nexport type CreateConversationFunction<TIntegration extends BaseIntegration> = (\n  props: CreateConversationArgs<TIntegration>\n) => Promise<Response | void>\n\nexport type ChannelFunctions<TIntegration extends BaseIntegration> = {\n  [ChannelName in keyof TIntegration['channels']]: {\n    messages: {\n      [MessageType in keyof TIntegration['channels'][ChannelName]['messages']]: (\n        props: CommonArgs<TIntegration> & MessageArgs<TIntegration, ChannelName, MessageType>\n      ) => Promise<void>\n    }\n  }\n}\n\nexport type IntegrationHandlers<TIntegration extends BaseIntegration> = {\n  register: RegisterFunction<TIntegration>\n  unregister: UnregisterFunction<TIntegration>\n  webhook: WebhookFunction<TIntegration>\n  createUser?: CreateUserFunction<TIntegration>\n  createConversation?: CreateConversationFunction<TIntegration>\n  actions: ActionFunctions<TIntegration>\n  channels: ChannelFunctions<TIntegration>\n}\n\ntype ServerProps<TIntegration extends BaseIntegration> = CommonArgs<TIntegration> & {\n  req: Request\n  instance: IntegrationHandlers<TIntegration>\n}\n\nexport const integrationHandler =\n  <TIntegration extends BaseIntegration>(instance: IntegrationHandlers<TIntegration>) =>\n  async (req: Request): Promise<Response | void> => {\n    const ctx = extractContext(req.headers)\n\n    const client = new IntegrationSpecificClient<TIntegration>(\n      new Client({ botId: ctx.botId, integrationId: ctx.integrationId })\n    )\n\n    const props = {\n      ctx,\n      req,\n      client,\n      logger: integrationLogger,\n      instance,\n    }\n\n    try {\n      let response: Response | void\n      switch (ctx.operation) {\n        case 'webhook_received':\n          response = await onWebhook<TIntegration>(props)\n          break\n        case 'register':\n          response = await onRegister<TIntegration>(props)\n          break\n        case 'unregister':\n          response = await onUnregister<TIntegration>(props)\n          break\n        case 'message_created':\n          response = await onMessageCreated<TIntegration>(props)\n          break\n        case 'action_triggered':\n          response = await onActionTriggered<TIntegration>(props)\n          break\n        case 'ping':\n          response = await onPing<TIntegration>(props)\n          break\n        case 'create_user':\n          response = await onCreateUser<TIntegration>(props)\n          break\n        case 'create_conversation':\n          response = await onCreateConversation<TIntegration>(props)\n          break\n        default:\n          throw new Error(`Unknown operation ${ctx.operation}`)\n      }\n      return response ? { ...response, status: response.status ?? 200 } : { status: 200 }\n    } catch (thrown) {\n      if (isApiError(thrown)) {\n        const runtimeError = new RuntimeError(thrown.message, thrown)\n        return { status: runtimeError.code, body: JSON.stringify(runtimeError.toJSON()) }\n      }\n      throw thrown\n    }\n  }\n\nconst onPing = async <TIntegration extends BaseIntegration>(_: ServerProps<TIntegration>) => {}\n\nconst onWebhook = async <TIntegration extends BaseIntegration>({\n  client,\n  ctx,\n  req: incomingRequest,\n  logger,\n  instance,\n}: ServerProps<TIntegration>) => {\n  const { req } = parseBody<WebhookPayload>(incomingRequest)\n  return instance.webhook({ client, ctx, req, logger })\n}\n\nconst onRegister = async <TIntegration extends BaseIntegration>({\n  client,\n  ctx,\n  req,\n  logger,\n  instance,\n}: ServerProps<TIntegration>) => {\n  if (!instance.register) {\n    return\n  }\n  const { webhookUrl } = parseBody<RegisterPayload>(req)\n  await instance.register({ client, ctx, webhookUrl, logger })\n}\n\nconst onUnregister = async <TIntegration extends BaseIntegration>({\n  client,\n  ctx,\n  req,\n  logger,\n  instance,\n}: ServerProps<TIntegration>) => {\n  if (!instance.unregister) {\n    return\n  }\n  const { webhookUrl } = parseBody<UnregisterPayload>(req)\n  await instance.unregister({ ctx, webhookUrl, client, logger })\n}\n\nconst onCreateUser = async <TIntegration extends BaseIntegration>({\n  client,\n  ctx,\n  req,\n  logger,\n  instance,\n}: ServerProps<TIntegration>) => {\n  if (!instance.createUser) {\n    return\n  }\n  const { tags } = parseBody<CreateUserPayload<TIntegration>>(req)\n  return await instance.createUser({ ctx, client, tags, logger })\n}\n\nconst onCreateConversation = async <TIntegration extends BaseIntegration>({\n  client,\n  ctx,\n  req,\n  logger,\n  instance,\n}: ServerProps<TIntegration>) => {\n  if (!instance.createConversation) {\n    return\n  }\n  const { channel, tags } = parseBody<CreateConversationPayload<TIntegration>>(req)\n  return await instance.createConversation({ ctx, client, channel, tags, logger })\n}\n\nconst onMessageCreated = async <TIntegration extends BaseIntegration>({\n  ctx,\n  req,\n  client,\n  logger,\n  instance,\n}: ServerProps<TIntegration>) => {\n  const { conversation, user, type, payload, message } = parseBody<MessagePayload<TIntegration, string, string>>(req)\n\n  const channelHandler = instance.channels[conversation.channel]\n\n  if (!channelHandler) {\n    throw new Error(`Channel ${conversation.channel} not found`)\n  }\n\n  const messageHandler = channelHandler.messages[type]\n\n  if (!messageHandler) {\n    throw new Error(`Message of type ${type} not found in channel ${conversation.channel}`)\n  }\n\n  type UpdateMessageProps = Parameters<(typeof client)['updateMessage']>[0]\n  const ack = async ({ tags }: Pick<UpdateMessageProps, 'tags'>) => {\n    await client.updateMessage({\n      id: message.id,\n      tags,\n    })\n  }\n\n  await messageHandler({ ctx, conversation, message, user, type, client, payload, ack, logger })\n}\n\nconst onActionTriggered = async <TIntegration extends BaseIntegration>({\n  req,\n  ctx,\n  client,\n  logger,\n  instance,\n}: ServerProps<TIntegration>) => {\n  const { input, type } = parseBody<ActionPayload<string, any>>(req)\n\n  if (!type) {\n    throw new Error('Missing action type')\n  }\n\n  const action = instance.actions[type]\n\n  if (!action) {\n    throw new Error(`Action ${type} not found`)\n  }\n\n  const output = await action({ ctx, input, client, type, logger })\n\n  return {\n    body: JSON.stringify({ output }),\n  }\n}\n", "import { Client } from '@botpress/client'\nimport { BaseIntegration } from '../generic'\nimport * as routes from './routes'\n\n/**\n * Just like the regular botpress client, but typed with the integration's properties.\n */\nexport class IntegrationSpecificClient<TIntegration extends BaseIntegration> {\n  public constructor(private readonly client: Client) {}\n\n  public createConversation: routes.CreateConversation<TIntegration> = ((x) =>\n    this.client.createConversation(x)) as routes.CreateConversation<TIntegration>\n  public getConversation: routes.GetConversation<TIntegration> = ((x) =>\n    this.client.getConversation(x)) as routes.GetConversation<TIntegration>\n  public listConversations: routes.ListConversations<TIntegration> = ((x) =>\n    this.client.listConversations(x)) as routes.ListConversations<TIntegration>\n  public getOrCreateConversation: routes.GetOrCreateConversation<TIntegration> = ((x) =>\n    this.client.getOrCreateConversation(x)) as routes.GetOrCreateConversation<TIntegration>\n  public updateConversation: routes.UpdateConversation<TIntegration> = ((x) =>\n    this.client.updateConversation(x)) as routes.UpdateConversation<TIntegration>\n  public deleteConversation: routes.DeleteConversation<TIntegration> = ((x) =>\n    this.client.deleteConversation(x)) as routes.DeleteConversation<TIntegration>\n\n  public listParticipants: routes.ListParticipants<TIntegration> = ((x) =>\n    this.client.listParticipants(x)) as routes.ListParticipants<TIntegration>\n  public addParticipant: routes.AddParticipant<TIntegration> = ((x) =>\n    this.client.addParticipant(x)) as routes.AddParticipant<TIntegration>\n  public getParticipant: routes.GetParticipant<TIntegration> = ((x) =>\n    this.client.getParticipant(x)) as routes.GetParticipant<TIntegration>\n  public removeParticipant: routes.RemoveParticipant<TIntegration> = ((x) =>\n    this.client.removeParticipant(x)) as routes.RemoveParticipant<TIntegration>\n\n  public createEvent: routes.CreateEvent<TIntegration> = ((x) =>\n    this.client.createEvent(x)) as routes.CreateEvent<TIntegration>\n  public getEvent: routes.GetEvent<TIntegration> = ((x) => this.client.getEvent(x)) as routes.GetEvent<TIntegration>\n  public listEvents: routes.ListEvents<TIntegration> = ((x) =>\n    this.client.listEvents(x)) as routes.ListEvents<TIntegration>\n\n  public createMessage: routes.CreateMessage<TIntegration> = ((x) =>\n    this.client.createMessage(x)) as routes.CreateMessage<TIntegration>\n  public getOrCreateMessage: routes.GetOrCreateMessage<TIntegration> = ((x) =>\n    this.client.getOrCreateMessage(x)) as routes.GetOrCreateMessage<TIntegration>\n  public getMessage: routes.GetMessage<TIntegration> = ((x) =>\n    this.client.getMessage(x)) as routes.GetMessage<TIntegration>\n  public updateMessage: routes.UpdateMessage<TIntegration> = ((x) =>\n    this.client.updateMessage(x)) as routes.UpdateMessage<TIntegration>\n  public listMessages: routes.ListMessages<TIntegration> = ((x) =>\n    this.client.listMessages(x)) as routes.ListMessages<TIntegration>\n  public deleteMessage: routes.DeleteMessage<TIntegration> = ((x) =>\n    this.client.deleteMessage(x)) as routes.DeleteMessage<TIntegration>\n\n  public createUser: routes.CreateUser<TIntegration> = ((x) =>\n    this.client.createUser(x)) as routes.CreateUser<TIntegration>\n  public getUser: routes.GetUser<TIntegration> = ((x) => this.client.getUser(x)) as routes.GetUser<TIntegration>\n  public listUsers: routes.ListUsers<TIntegration> = (x) => this.client.listUsers(x)\n  public getOrCreateUser: routes.GetOrCreateUser<TIntegration> = ((x) =>\n    this.client.getOrCreateUser(x)) as routes.GetOrCreateUser<TIntegration>\n  public updateUser: routes.UpdateUser<TIntegration> = ((x) =>\n    this.client.updateUser(x)) as routes.UpdateUser<TIntegration>\n  public deleteUser: routes.DeleteUser<TIntegration> = (x) => this.client.deleteUser(x)\n\n  public getState: routes.GetState<TIntegration> = ((x) => this.client.getState(x)) as routes.GetState<TIntegration>\n  public setState: routes.SetState<TIntegration> = ((x) => this.client.setState(x)) as routes.SetState<TIntegration>\n  public getOrSetState: routes.GetOrSetState<TIntegration> = ((x) =>\n    this.client.getOrSetState(x)) as routes.GetOrSetState<TIntegration>\n  public patchState: routes.PatchState<TIntegration> = ((x) =>\n    this.client.patchState(x)) as routes.PatchState<TIntegration>\n\n  public configureIntegration: routes.ConfigureIntegration<TIntegration> = (x) => this.client.configureIntegration(x)\n\n  public uploadFile: routes.UploadFile<TIntegration> = (x) => this.client.uploadFile(x)\n  public upsertFile: routes.UpsertFile<TIntegration> = (x) => this.client.upsertFile(x)\n  public deleteFile: routes.DeleteFile<TIntegration> = (x) => this.client.deleteFile(x)\n  public listFiles: routes.ListFiles<TIntegration> = (x) => this.client.listFiles(x)\n  public getFile: routes.GetFile<TIntegration> = (x) => this.client.getFile(x)\n  public updateFileMetadata: routes.UpdateFileMetadata<TIntegration> = (x) => this.client.updateFileMetadata(x)\n}\n", "/* eslint-disable no-console */\nimport util from 'util'\n\nconst serializeForBotMessage = (args: Parameters<typeof util.format>) => {\n  if (process.env['BP_LOG_FORMAT'] === 'json') {\n    return JSON.stringify({ msg: util.format(...args), visible_to_bot_owner: true })\n  } else {\n    const [format, ...param] = args\n    return util.format(`[For Bot Owner] ${format}`, ...param)\n  }\n}\n\nexport const integrationLogger = {\n  /**\n   * Use this function to log messages that will be displayed to the Bot Owner.\n   */\n  forBot: () => {\n    return {\n      info: (...args: Parameters<typeof console.info>) => {\n        console.info(serializeForBotMessage(args))\n      },\n      warn: (...args: Parameters<typeof console.warn>) => {\n        console.warn(serializeForBotMessage(args))\n      },\n      error: (...args: Parameters<typeof console.error>) => {\n        console.error(serializeForBotMessage(args))\n      },\n      debug: (...args: Parameters<typeof console.debug>) => {\n        console.debug(serializeForBotMessage(args))\n      },\n    }\n  },\n}\n\nexport type IntegrationLogger = typeof integrationLogger\n", "import type { Server } from 'node:http'\nimport { serve } from '../serve'\nimport { BaseIntegration } from './generic'\nimport {\n  RegisterFunction,\n  UnregisterFunction,\n  WebhookFunction,\n  CreateUserFunction,\n  CreateConversationFunction,\n  ActionFunctions,\n  ChannelFunctions,\n  integrationHandler,\n} from './server'\n\nexport type IntegrationImplementationProps<TIntegration extends BaseIntegration = BaseIntegration> = {\n  register: RegisterFunction<TIntegration>\n  unregister: UnregisterFunction<TIntegration>\n  handler: WebhookFunction<TIntegration>\n  /**\n   * @deprecated\n   */\n  createUser?: CreateUserFunction<TIntegration>\n  /**\n   * @deprecated\n   */\n  createConversation?: CreateConversationFunction<TIntegration>\n  actions: ActionFunctions<TIntegration>\n  channels: ChannelFunctions<TIntegration>\n}\n\nexport class IntegrationImplementation<TIntegration extends BaseIntegration = BaseIntegration> {\n  public readonly props: IntegrationImplementationProps<TIntegration>\n  public readonly actions: IntegrationImplementationProps<TIntegration>['actions']\n  public readonly channels: IntegrationImplementationProps<TIntegration>['channels']\n  public readonly register: IntegrationImplementationProps<TIntegration>['register']\n  public readonly unregister: IntegrationImplementationProps<TIntegration>['unregister']\n  public readonly createUser: IntegrationImplementationProps<TIntegration>['createUser']\n  public readonly createConversation: IntegrationImplementationProps<TIntegration>['createConversation']\n  public readonly webhook: IntegrationImplementationProps<TIntegration>['handler']\n\n  public constructor(props: IntegrationImplementationProps<TIntegration>) {\n    this.props = props\n    this.actions = props.actions\n    this.channels = props.channels\n    this.register = props.register\n    this.unregister = props.unregister\n    this.createUser = props.createUser\n    this.createConversation = props.createConversation\n    this.webhook = props.handler\n  }\n\n  public readonly handler = integrationHandler<TIntegration>(this)\n  public readonly start = (port?: number): Promise<Server> => serve(this.handler, port)\n}\n", "import * as client from '@botpress/client'\nimport { log } from '../log'\nimport { Request, Response, parseBody } from '../serve'\nimport { BotSpecificClient } from './client'\nimport * as types from './client/types'\nimport { BotContext, extractContext } from './context'\nimport { BaseBot } from './generic'\n\ntype CommonArgs<TBot extends BaseBot> = {\n  ctx: BotContext\n  client: BotSpecificClient<TBot>\n}\n\ntype MessagePayload<TBot extends BaseBot> = {\n  user: client.User\n  conversation: client.Conversation\n  message: types.MessageResponse<TBot>['message']\n  event: client.Event\n  states: {\n    [TState in keyof TBot['states']]: {\n      type: StateType\n      payload: TBot['states'][TState]\n    }\n  }\n}\ntype MessageArgs<TBot extends BaseBot> = CommonArgs<TBot> & MessagePayload<TBot>\n\ntype EventPayload<TBot extends BaseBot> = types.EventResponse<TBot>\ntype EventArgs<TBot extends BaseBot> = CommonArgs<TBot> & EventPayload<TBot>\n\ntype StateExpiredPayload = { state: client.State }\ntype StateExpiredArgs<TBot extends BaseBot> = CommonArgs<TBot> & StateExpiredPayload\n\nexport type StateType = 'conversation' | 'user' | 'bot'\n\nexport type MessageHandler<TBot extends BaseBot> = (args: MessageArgs<TBot>) => Promise<void>\n\nexport type EventHandler<TBot extends BaseBot> = (args: EventArgs<TBot>) => Promise<void>\n\nexport type StateExpiredHandler<TBot extends BaseBot> = (args: StateExpiredArgs<TBot>) => Promise<void>\n\nexport type BotHandlers<TBot extends BaseBot> = {\n  messageHandlers: MessageHandler<TBot>[]\n  eventHandlers: EventHandler<TBot>[]\n  stateExpiredHandlers: StateExpiredHandler<TBot>[]\n}\n\ntype ServerProps<TBot extends BaseBot> = CommonArgs<TBot> & {\n  req: Request\n  instance: BotHandlers<TBot>\n}\n\nexport const botHandler =\n  <TBot extends BaseBot>(instance: BotHandlers<TBot>) =>\n  async (req: Request): Promise<Response | void> => {\n    const ctx = extractContext(req.headers)\n\n    if (ctx.operation !== 'ping') {\n      log.info(`Received ${ctx.operation} operation for bot ${ctx.botId} of type ${ctx.type}`)\n    }\n\n    const botClient = new BotSpecificClient<TBot>(new client.Client({ botId: ctx.botId }))\n\n    const props: ServerProps<TBot> = {\n      req,\n      ctx,\n      client: botClient,\n      instance,\n    }\n\n    switch (ctx.operation) {\n      case 'action_triggered':\n        throw new Error(`Operation ${ctx.operation} not supported yet`)\n      case 'event_received':\n        await onEventReceived<TBot>(props as ServerProps<TBot>)\n        break\n      case 'register':\n        await onRegister<TBot>(props as ServerProps<TBot>)\n        break\n      case 'unregister':\n        await onUnregister<TBot>(props as ServerProps<TBot>)\n        break\n      case 'ping':\n        await onPing<TBot>(props as ServerProps<TBot>)\n        break\n      default:\n        throw new Error(`Unknown operation ${ctx.operation}`)\n    }\n\n    return { status: 200 }\n  }\n\nconst onPing = async <TBot extends BaseBot>(_: ServerProps<TBot>) => {}\nconst onRegister = async <TBot extends BaseBot>(_: ServerProps<TBot>) => {}\nconst onUnregister = async <TBot extends BaseBot>(_: ServerProps<TBot>) => {}\nconst onEventReceived = async <TBot extends BaseBot>({ ctx, req, client, instance }: ServerProps<TBot>) => {\n  log.debug(`Received event ${ctx.type}`)\n\n  const body = parseBody<EventPayload<TBot>>(req)\n  const event = body.event as client.Event\n\n  switch (ctx.type) {\n    case 'message_created':\n      const messagePayload: MessagePayload<TBot> = {\n        user: event.payload.user,\n        conversation: event.payload.conversation,\n        message: event.payload.message,\n        states: event.payload.states,\n        event,\n      }\n\n      await Promise.all(\n        instance.messageHandlers.map((handler) =>\n          handler({\n            client,\n            ctx,\n            ...messagePayload,\n          })\n        )\n      )\n      break\n    case 'state_expired':\n      const statePayload: StateExpiredPayload = { state: event.payload.state }\n      await Promise.all(\n        instance.stateExpiredHandlers.map((handler) =>\n          handler({\n            client,\n            ctx,\n            ...statePayload,\n          })\n        )\n      )\n      break\n    default:\n      const eventPayload = { event: body.event } as EventPayload<TBot>\n      await Promise.all(\n        instance.eventHandlers.map((handler) =>\n          handler({\n            client,\n            ctx,\n            ...eventPayload,\n          })\n        )\n      )\n  }\n}\n", "import { Client } from '@botpress/client'\nimport { BaseBot } from '../generic'\nimport * as routes from './routes'\n\n/**\n * Just like the regular botpress client, but typed with the bot's properties.\n */\nexport class BotSpecificClient<TBot extends BaseBot> {\n  public constructor(private readonly client: Client) {}\n\n  public getConversation: routes.GetConversation<TBot> = (x) => this.client.getConversation(x)\n  public listConversations: routes.ListConversations<TBot> = (x) => this.client.listConversations(x)\n  public updateConversation: routes.UpdateConversation<TBot> = (x) => this.client.updateConversation(x)\n  public deleteConversation: routes.DeleteConversation<TBot> = (x) => this.client.deleteConversation(x)\n\n  public listParticipants: routes.ListParticipants<TBot> = (x) => this.client.listParticipants(x)\n  public addParticipant: routes.AddParticipant<TBot> = (x) => this.client.addParticipant(x)\n  public getParticipant: routes.GetParticipant<TBot> = (x) => this.client.getParticipant(x)\n  public removeParticipant: routes.RemoveParticipant<TBot> = (x) => this.client.removeParticipant(x)\n\n  public getEvent: routes.GetEvent<TBot> = ((x) => this.client.getEvent(x)) as routes.GetEvent<TBot>\n  public listEvents: routes.ListEvents<TBot> = ((x) => this.client.listEvents(x)) as routes.ListEvents<TBot>\n\n  public createMessage: routes.CreateMessage<TBot> = ((x) => this.client.createMessage(x)) as routes.CreateMessage<TBot>\n  public getOrCreateMessage: routes.GetOrCreateMessage<TBot> = ((x) =>\n    this.client.getOrCreateMessage(x)) as routes.GetOrCreateMessage<TBot>\n  public getMessage: routes.GetMessage<TBot> = ((x) => this.client.getMessage(x)) as routes.GetMessage<TBot>\n  public updateMessage: routes.UpdateMessage<TBot> = ((x) => this.client.updateMessage(x)) as routes.UpdateMessage<TBot>\n  public listMessages: routes.ListMessages<TBot> = ((x) => this.client.listMessages(x)) as routes.ListMessages<TBot>\n  public deleteMessage: routes.DeleteMessage<TBot> = ((x) => this.client.deleteMessage(x)) as routes.DeleteMessage<TBot>\n\n  public getUser: routes.GetUser<TBot> = (x) => this.client.getUser(x)\n  public listUsers: routes.ListUsers<TBot> = (x) => this.client.listUsers(x)\n  public updateUser: routes.UpdateUser<TBot> = (x) => this.client.updateUser(x)\n  public deleteUser: routes.DeleteUser<TBot> = (x) => this.client.deleteUser(x)\n\n  public getState: routes.GetState<TBot> = ((x) =>\n    this.client.getState(x).then((y) => ({ state: { ...y.state, payload: y.state.payload } }))) as routes.GetState<TBot>\n  public setState: routes.SetState<TBot> = ((x) =>\n    this.client.setState(x).then((y) => ({ state: { ...y.state, payload: y.state.payload } }))) as routes.SetState<TBot>\n  public getOrSetState: routes.GetOrSetState<TBot> = ((x) =>\n    this.client\n      .getOrSetState(x)\n      .then((y) => ({ state: { ...y.state, payload: y.state.payload } }))) as routes.GetOrSetState<TBot>\n  public patchState: routes.PatchState<TBot> = ((x) =>\n    this.client\n      .patchState(x)\n      .then((y) => ({ state: { ...y.state, payload: y.state.payload } }))) as routes.PatchState<TBot>\n\n  public callAction: routes.CallAction<TBot> = (x) => this.client.callAction(x)\n\n  public uploadFile: routes.UploadFile<TBot> = (x) => this.client.uploadFile(x)\n  public upsertFile: routes.UpsertFile<TBot> = (x) => this.client.upsertFile(x)\n  public deleteFile: routes.DeleteFile<TBot> = (x) => this.client.deleteFile(x)\n  public listFiles: routes.ListFiles<TBot> = (x) => this.client.listFiles(x)\n  public getFile: routes.GetFile<TBot> = (x) => this.client.getFile(x)\n  public updateFileMetadata: routes.UpdateFileMetadata<TBot> = (x) => this.client.updateFileMetadata(x)\n  public searchFiles: routes.SearchFiles<TBot> = (x) => this.client.searchFiles(x)\n\n  /**\n   * @deprecated Use `callAction` to delegate the conversation creation to an integration.\n   */\n  public createConversation: routes.CreateConversation<TBot> = (x) => this.client.createConversation(x)\n  /**\n   * @deprecated Use `callAction` to delegate the conversation creation to an integration.\n   */\n  public getOrCreateConversation: routes.GetOrCreateConversation<TBot> = (x) => this.client.getOrCreateConversation(x)\n  /**\n   * @deprecated Use `callAction` to delegate the user creation to an integration.\n   */\n  public createUser: routes.CreateUser<TBot> = (x) => this.client.createUser(x)\n  /**\n   * @deprecated Use `callAction` to delegate the user creation to an integration.\n   */\n  public getOrCreateUser: routes.GetOrCreateUser<TBot> = (x) => this.client.getOrCreateUser(x)\n}\n", "import { z } from '@bpinternal/zui'\nimport { botIdHeader, configurationHeader, operationHeader, typeHeader } from '../const'\n\nexport const botOperationSchema = z.enum(['event_received', 'register', 'unregister', 'ping', 'action_triggered'])\n\nexport type BotOperation = z.infer<typeof botOperationSchema>\n\nexport type BotContext = {\n  botId: string\n  type: string\n  operation: BotOperation\n  configuration: {\n    payload: string\n  }\n}\n\nexport const extractContext = (headers: Record<string, string | undefined>): BotContext => {\n  const botId = headers[botIdHeader]\n  const base64Configuration = headers[configurationHeader]\n  const type = headers[typeHeader]\n  const operation = botOperationSchema.parse(headers[operationHeader])\n\n  if (!botId) {\n    throw new Error('Missing bot headers')\n  }\n\n  if (!type) {\n    throw new Error('Missing type headers')\n  }\n\n  if (!base64Configuration) {\n    throw new Error('Missing configuration headers')\n  }\n\n  if (!operation) {\n    throw new Error('Missing operation headers')\n  }\n\n  return {\n    botId,\n    operation,\n    type,\n    configuration: base64Configuration ? JSON.parse(Buffer.from(base64Configuration, 'base64').toString('utf-8')) : {},\n  }\n}\n", "import { z } from '@bpinternal/zui'\nimport type { Server } from 'node:http'\nimport { SchemaDefinition } from '../schema'\nimport { serve } from '../serve'\nimport { AnyZodObject } from '../type-utils'\nimport { BaseIntegrations } from './generic'\nimport { IntegrationInstance } from './integration-instance'\nimport { botHandler, MessageHandler, EventHandler, StateExpiredHandler, StateType } from './server'\n\ntype BaseStates = Record<string, AnyZodObject>\ntype BaseEvents = Record<string, AnyZodObject>\n\ntype TagDefinition = {\n  title?: string\n  description?: string\n}\n\ntype StateDefinition<TState extends BaseStates[string]> = SchemaDefinition<TState> & {\n  type: StateType\n  expiry?: number\n}\n\ntype RecurringEventDefinition<TEvents extends BaseEvents> = {\n  [K in keyof TEvents]: {\n    type: K\n    payload: z.infer<TEvents[K]>\n    schedule: { cron: string }\n  }\n}[keyof TEvents]\n\ntype EventDefinition<TEvent extends BaseEvents[string]> = SchemaDefinition<TEvent>\n\ntype ConfigurationDefinition = SchemaDefinition\n\ntype UserDefinition = {\n  tags?: Record<string, TagDefinition>\n}\n\ntype ConversationDefinition = {\n  tags?: Record<string, TagDefinition>\n}\n\ntype MessageDefinition = {\n  tags?: Record<string, TagDefinition>\n}\n\nexport type BotProps<\n  TIntegrations extends BaseIntegrations = BaseIntegrations,\n  TStates extends BaseStates = BaseStates,\n  TEvents extends BaseEvents = BaseEvents\n> = {\n  integrations?: {\n    [K in keyof TIntegrations]?: IntegrationInstance<TIntegrations[K]>\n  }\n  user?: UserDefinition\n  conversation?: ConversationDefinition // TODO: add configuration to generic and infer from there\n  message?: MessageDefinition\n  states?: {\n    [K in keyof TStates]: StateDefinition<TStates[K]>\n  }\n  configuration?: ConfigurationDefinition\n  events?: {\n    [K in keyof TEvents]: EventDefinition<TEvents[K]>\n  }\n  recurringEvents?: Record<string, RecurringEventDefinition<TEvents>>\n}\n\ntype BotFrom<TIntegrations extends BaseIntegrations, TStates extends BaseStates, TEvents extends BaseEvents> = {\n  integrations: TIntegrations\n  states: {\n    [K in keyof TStates]: z.infer<TStates[K]>\n  }\n  events: {\n    [K in keyof TEvents]: z.infer<TEvents[K]>\n  }\n}\n\ntype BotState<\n  TIntegrations extends BaseIntegrations = BaseIntegrations,\n  TStates extends BaseStates = BaseStates,\n  TEvents extends BaseEvents = BaseEvents\n> = {\n  messageHandlers: MessageHandler<BotFrom<TIntegrations, TStates, TEvents>>[]\n  eventHandlers: EventHandler<BotFrom<TIntegrations, TStates, TEvents>>[]\n  stateExpiredHandlers: StateExpiredHandler<BotFrom<TIntegrations, TStates, TEvents>>[]\n}\n\nexport class Bot<\n  TIntegrations extends BaseIntegrations = BaseIntegrations,\n  TStates extends BaseStates = BaseStates,\n  TEvents extends BaseEvents = BaseEvents\n> {\n  private _state: BotState<TIntegrations, TStates, TEvents> = {\n    messageHandlers: [],\n    eventHandlers: [],\n    stateExpiredHandlers: [],\n  }\n\n  public readonly props: BotProps<TIntegrations, TStates, TEvents>\n\n  public constructor(props: BotProps<TIntegrations, TStates, TEvents>) {\n    this.props = props\n  }\n\n  public readonly message = (handler: MessageHandler<BotFrom<TIntegrations, TStates, TEvents>>): void => {\n    this._state.messageHandlers.push(handler)\n  }\n  public readonly event = (handler: EventHandler<BotFrom<TIntegrations, TStates, TEvents>>): void => {\n    this._state.eventHandlers.push(handler)\n  }\n  public readonly stateExpired = (handler: StateExpiredHandler<BotFrom<TIntegrations, TStates, TEvents>>): void => {\n    this._state.stateExpiredHandlers.push(handler)\n  }\n\n  public readonly handler = botHandler(this._state)\n  public readonly start = (port?: number): Promise<Server> => serve(this.handler, port)\n}\n"],
  "mappings": "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",
  "names": ["src_exports", "__export", "Bot", "BotSpecificClient", "IntegrationImplementation", "IntegrationDefinition", "IntegrationSpecificClient", "InterfaceDeclaration", "botIdHeader", "botUserIdHeader", "configurationHeader", "integrationIdHeader", "interfaces_exports", "message_exports", "operationHeader", "parseBody", "serve", "studioComponentDefinitions", "typeHeader", "webhookIdHeader", "__toCommonJS", "message_exports", "__export", "defaults", "zui_exports", "__export", "zui_default", "studioComponentDefinitions", "import_zui", "__reExport", "commonInputParams", "NonEmptyString", "textMessageSchema", "markdownMessageSchema", "imageMessageSchema", "audioMessageSchema", "videoMessageSchema", "fileMessageSchema", "locationMessageSchema", "cardSchema", "choiceSchema", "carouselSchema", "blocSchema", "blocsSchema", "defaults", "interfaces_exports", "__export", "creatable", "deletable", "listable", "llm", "readable", "schemas_exports", "speechToText", "textToImage", "updatable", "unique", "array", "pairs", "obj", "mapValues", "obj", "fn", "pairs", "key", "value", "mergeRecords", "a", "b", "merge", "keys", "unique", "result", "aValue", "bValue", "schemaName", "createStore", "props", "mapValues", "e", "k", "isBranded", "schema", "getName", "IntegrationDefinition", "props", "clone", "key", "value", "interfaceDeclaration", "builder", "extensionBuilderOutput", "createStore", "unbrandedEntity", "pairs", "_k", "e", "isBranded", "interfaceTypeArguments", "mapValues", "getName", "resolved", "implementStatement", "self", "mergeRecords", "entityNames", "a", "b", "messages", "InterfaceDeclaration", "props", "entities", "implementStatement", "mapValues", "entity", "actions", "events", "channels", "actionName", "action", "pairs", "resolvedInputSchema", "resolvedOutputSchema", "newActionName", "eventName", "event", "resolvedEventSchema", "newEventName", "channelName", "channel", "messages", "messageName", "message", "resolvedMessageSchema", "generic", "entitySchemas", "entityReferences", "entityName", "zui_default", "name", "templateProps", "ToolCallSchema", "zui_default", "ToolChoiceSchema", "MessageSchema", "ModelRefSchema", "ModelSchema", "GenerateContentInputSchema", "modelRefSchema", "GenerateContentInputBaseSchema", "GenerateContentOutputSchema", "llm", "InterfaceDeclaration", "modelRef", "ImageModelRefSchema", "zui_default", "ImageModelSchema", "ImageGenerationParamsSchema", "GenerateImageInputSchema", "imageModelRefSchema", "paramsSchema", "GenerateContentInputBaseSchema", "GenerateImageOutputSchema", "textToImage", "InterfaceDeclaration", "imageModelRef", "imageGenerationParams", "speech_to_text_exports", "__export", "OpenAITranscribeAudioOutputSchema", "OpenAITranscribeAudioOutputSchema", "zui_default", "SpeechModelRefSchema", "zui_default", "SpeechToTextModelSchema", "TranscribeAudioInputSchema", "imageModelRefSchema", "TranscribeAudioBaseSchema", "TranscribeAudioOutputSchema", "OpenAITranscribeAudioOutputSchema", "speechToText", "InterfaceDeclaration", "speechToTextModelRef", "schemas_exports", "__export", "speech_to_text_exports", "baseItem", "zui_default", "withId", "schema", "capitalize", "s", "camelCase", "parts", "first", "rest", "nextToken", "listable", "InterfaceDeclaration", "args", "name", "props", "creatable", "readable", "updatable", "deletable", "botIdHeader", "botUserIdHeader", "integrationIdHeader", "webhookIdHeader", "configurationHeader", "operationHeader", "typeHeader", "import_node_http", "log", "parseBody", "req", "serve", "handler", "port", "callback", "defaultCallback", "server", "res", "request", "mapIncomingMessageToRequest", "response", "e", "log", "incoming", "body", "readBody", "headers", "i", "key", "value", "url", "trimPrefix", "prefix", "resolve", "reject", "chunk", "__reExport", "src_exports", "zui_exports", "import_client", "import_zui", "integrationOperationSchema", "extractContext", "headers", "botId", "botIdHeader", "botUserId", "botUserIdHeader", "integrationId", "integrationIdHeader", "webhookId", "webhookIdHeader", "base64Configuration", "configurationHeader", "operation", "operationHeader", "import_client", "IntegrationSpecificClient", "client", "x", "import_util", "serializeForBotMessage", "args", "util", "format", "param", "integrationLogger", "integrationHandler", "instance", "req", "ctx", "extractContext", "client", "IntegrationSpecificClient", "props", "integrationLogger", "response", "onWebhook", "onRegister", "onUnregister", "onMessageCreated", "onActionTriggered", "onPing", "onCreateUser", "onCreateConversation", "thrown", "runtimeError", "_", "incomingRequest", "logger", "parseBody", "webhookUrl", "tags", "channel", "conversation", "user", "type", "payload", "message", "channelHandler", "messageHandler", "input", "action", "output", "IntegrationImplementation", "props", "integrationHandler", "port", "serve", "client", "BotSpecificClient", "client", "x", "y", "import_zui", "botOperationSchema", "extractContext", "headers", "botId", "botIdHeader", "base64Configuration", "configurationHeader", "type", "typeHeader", "operation", "operationHeader", "botHandler", "instance", "req", "ctx", "extractContext", "log", "botClient", "BotSpecificClient", "props", "onEventReceived", "onRegister", "onUnregister", "onPing", "_", "client", "body", "parseBody", "event", "messagePayload", "handler", "statePayload", "eventPayload", "Bot", "props", "handler", "botHandler", "port", "serve"]
}
